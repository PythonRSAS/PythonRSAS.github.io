---
layout: post
tag: The art of Learning
category: education
title: "Learn recursion"
description: getting the simplest things right
author: Sarah Chen
image: https://en.wikipedia.org/wiki/Romanesco_broccoli#/media/File:Romanesco_broccoli_(3).jpg
# image: images/posts/photos/IMG-0632.JPG
---
<!-- <figure> 
   <img src="{{"/images/posts/photos/IMG-0632.JPG"| relative_url}}"> 
   <figcaption></figcaption>
</figure>  -->


# What is recursion

> Recursion is like brocolli (or cauliflower). 

![Romanesco_broccoli](https://i0.wp.com/growingwithplants.com/wp-content/uploads/2011/10/romanesco.jpg?w=640)

Recursion is a function that is defined with itself.  $$f(n) = \text{some combination of }f(n-1)$$.   What does that supposed to mean?  

![](https://en.wikipedia.org/wiki/Recursion#/media/File:Sierpinski_triangle.svg)

The simplest example I think is the natural number sequence $$1, 2, 3, 4, 5, 6, ...$$

## Natural number
The natural numbers can be expressed as:

$$f(n)=f(n-1)+1$$, with the initial condition that the first number is $$0$$ (when $$n=0$$).  
**The initial values must be given in order for the recursion to be fully defined**. 

|  n   |   0 |   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9 |
|:-----|----:|----:|----:|----:|----:|----:|----:|----:|----:|----:|
| f(n) |  **1** |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9 |  10 |


> if input is equal to initial value, then return the values for initial values
> else return the mathematical function

Translate it to code.
-------------------- 
If (initial) input value is $$0$$, output is $$1$$. 
Else output the (value generated by) the mathematical formula. 

In runtime, the recursive formula will unwind layer by layer (stacks) until the initial values.   

An aside: when most programs run, they allocate a single chunk of memory.  In Python, recursion is a lot slower to run than iterations using loops. 

<div class="code-head"><span>code</span>natural number.py</div>

```py
def f(n):
   if n == 0:
      return 1
   else:
      return f(n-1) + 1

for i in range(10):
   print(f(i))
``` 

## Fibonacci number
The Fibonacci numbers can be expressed as:

$$f(n)=f(n-1)+ f(n-2)$$, 
with the initial condition that the first and the second numbers $$1$$ and $$1$$ (when $$n=0$$ and $$n=1$$).  Again, **the initial values must be given in order for the recursion to be fully defined**. 


|        |   **0** |   **1** |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9 |
|:-------|----:|----:|----:|----:|----:|----:|----:|----:|----:|----:|
| fib(n) |   **1** |   **1** |   2 |   3 |   5 |   8 |  13 |  21 |  34 |  55 |


<div class="code-head"><span>code</span>fibonacci number.py</div>

```py
def fib(n):
   if (n== 0)|(n==1):
      return 1
   else:
      return fib(n -1) + fib(n-2)
for i in range(10):
   print(fib(i))

# lt = []
# for i in range(10):
#    print(fib(i))
#    lt.append(fib(i))
# df = pd.DataFrame({'fib(n)':lt})
# print(df.T.to_markdown())
``` 

## Factorial

The factorial is another simple example.  $$n! = n*(n-1)*...*1$$
<div class="code-head"><span>code</span>factorial.py</div>

```py
def fact(n):
   if n < 0:
      return -1
   elif n == 1:
      return 1
   else:
      return n*fact(n-1)
print(fact(5))
# 120
```
# Recipe for recursion

After working out the two simple examples successfully, we can use the same thinking process to tackle bigger recursion problems.
1. Write down the mathematical formula of recursion
2. Specify initial values correctly
3. Code it accordingly

Our recipe creation process feels like some kind of recursion too: we came up with a process (or a pattern of a process) that works and generalize it to future ones.  

Maybe history is a recursion as well...

# Mathematical induction

Mathematical induction is a twin sister of recursion.  

If something is true for the initial value of a sequence, 
And if we can prove that it is true for $$n+1$$ if assuming it is true for $$n$$, then it is true for all $$n$$. 

# Search binary search tree

Below code searches if a given value is in a binary search tree. 

What it does:
1. if taget is not found or is equal to the data that is in the current node, then return the current tree (**initial value**)
2. else if target is less than current nodde, then search the left child subtree
3. otherwise (if target is greater than current nodde) search the right child subtree
<div class="code-head"><span>code</span>search binary search tree.py</div>

```py
def search(tree, target):
   return (tree if not tree or tree.data == target else search(tree, left, target) if target < tree.data else search(tree.right, target))
```

# When to use or not to use recursion

Mathematically we don't see any reason why not to use it: it is elegant.

Sometimes, such as binary search trees, it is much faster and easy to code using recursion than otherwise. 

However in computer implementation, most programs typically do not start any computation until all the recursions have unwind until the base/initial case.  

For most languages, unless the language specifically has optmized recursions, the repeated stack calls mean as many stack calls as needed to reach the initial case, which can be quite slow in comparison with some other algorithms such as loops that are optimized in many languages.  In addition, the computer may run out of memory because of (millions of) function calls. 


# Future explorations

![Earth's most stunning fractal patterns](https://www.wired.com/2010/09/fractal-patterns-in-nature/)

