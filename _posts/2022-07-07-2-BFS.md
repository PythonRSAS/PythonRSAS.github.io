---
layout: post
tag : data structure, algorithm, BFS
category: education
title: "BFS"
description: Breadth-first search
author: Sarah Chen
image: images/posts/photos/IMG_0870.JPG

---

- [Introduction](#introduction)
- [BFS](#bfs)
  - [Compare iterative DFS and BFS](#compare-iterative-dfs-and-bfs)
- [Appendix](#appendix)
  - [NetworkX](#networkx)

# Introduction

Breadth-first search (BFS) is one of my favorite computer algorithms. It is also one of the simpliest algorithms for searching a graph.  [Prim's minimum spanning tree](2022-07-15-1-Minimum-spanning-tree-1.md) and [Dijkstra's single-source shortest-path](2022-07-18-1-Dijkstra-algorithm-shortest-path-between.md) use ideas similar to BFS.  


A BFS starts at some arbitrary node and explores its neighbors first **before moving to the next level** of neighbors, in a layer by layer fashion. 

BFS is a way to search graph broadly, and useful for **finding the shortest path**.  The algorithm discovers all nodes at distance $k$ from source node before discovering any nodes at distance $k+1$. 

BFS uses a *queue* data structure to track which node to visit next because the traversal is first in and first out (**FIFO**).  

# BFS

We are going to use BFS to traverse the following graph.  It is not drawn with "A" at the top, but we can imagine for ourselves however shape we prefer it to be. 
![](../images/undirectedGraph.PNG)

In code below, I use:
* an adjacency list (dictionary) to represent grpah
* a **deque** to keep track of the queue.  Deques are a generalization of stacks and queues.  From Python documentation: [Deques support thread-safe, memory efficient appends and pops from either side of the deque with approximately the same O(1) performance in either direction.](https://docs.python.org/3/library/collections.html#deque-objects).     Though list objects support similar operations, they are **optimized for fast fixed-length operations** and incur $$O(n)$$ memory movement costs for <span class="coding">pop(0)</span> and <span class="coding">insert(0, v)</span> operations which change both the size and position of the underlying data representation.

What the <span class="coding">bfs</span> function does is to visit nodes **layer by layer, and from left to right**. 

1. place starting node to the queue
2. while anything is in queue, pop the first item from the queue. 
3. if what's popped out has not been visited yet, add it to the
4.  <span class="coding">visited</span> is a set instead of a list. 


I could have used <span class="coding">extend</span> method instead of a for-loop to append each neighbor one by one because <span class="coding">extend</span> is much faster.  But there is no method that is the opposite of <span class="coding">extend</span> to pop multile items simutaneously.   So I stay with the for-loop. 

<div class="code-head"><span>code</span>BFS.py</div>

```python
graph ={
    'A': ['B', 'C'],
    'B': ['D', 'E', 'F'],
    'C': ['G'],
    'D': [],
    'E': [],
    'F': ['H'],
    'G': ['I'],
    'H': [],
    'G': []
}

from collections import deque
def bfs(G, startNode):
    # initialize
    Q = deque(startNode)
    visited = set()
    traversal = []

    while Q: # do until no more node left
        node = Q.popleft()
        if node not in visited:
            visited.add(node)
            traversal.append(node)
            Q.extend(G[node])
        
    return traversal

print(bfs(graph, 'A'))
``` 
Although the input graph is represented as if it is a directed graph, the BFS works fine if it is undirected just as well.  
```python
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E', 'F'],
    'C': ['A', 'G'],
    'D': ['B'],
    'E': ['B'],
    'F': ['B', 'H'],
    'G': ['C'],
    'H': ['F'],
    'G': ['C']
}
```
> The negative side is that we have to do more membership tests.  For example, when we are at the $$B$$ node, we have to ask if $$A$$ was in the <span class="coding">visited</span> even though we just came from A. 

## Compare iterative DFS and BFS

The non-recursive implementation is similar to breadth-first search but differs from it in two ways:

it uses a stack instead of a queue, and
it delays checking whether a node has been discovered until the node is popped from the stack rather than making this check before adding the node.
If G is a tree, replacing the queue of the breadth-first search algorithm with a stack will yield a depth-first search algorithm. For general graphs, replacing the stack of the iterative depth-first search implementation with a queue would also produce a breadth-first search algorithm, although a somewhat nonstandard one.[7]

# Appendix

## NetworkX
Code used for drawing the graph.  <span class="coding">nx.Graph</span> uses our adjacency dictionary of lists as input to construct the graph. 

<div class="code-head"><span>code</span>networkX draw graph.py</div>

```python
import networkx as nx
import matplotlib.pyplot as plt
# for my BFS example
options = {
    'node_color': 'red',
    'node_size': 250,
    'width': 3,
    'font_weight': 'bold',
    'with_labels': True
}
H = nx.Graph(graph)  # create a Graph dict mapping nodes to nbrs
list(H.edges())
# [('A', 'B'),
#  ('A', 'C'),
#  ('B', 'D'),
#  ('B', 'E'),
#  ('B', 'F'),
#  ('C', 'G'),
#  ('F', 'H')]
nx.draw_spectral(H, **options)
plt.savefig("undirectedGraph.PNG")
plt.show()
```

```python
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E', 'F'],
    'C': ['A', 'G'],
    'D': ['B'],
    'E': ['B'],
    'F': ['B', 'H'],
    'G': ['C'],
    'H': ['F'],
    'G': ['C']
}
H =  nx.Graph(graph) 
H.degree()
# DegreeView({'A': 2, 'B': 4, 'C': 2, 'D': 1, 'E': 1, 'F': 2, 'G': 1, 'H': 1})
```


```python
H =  nx.DiGraph(graph) # directed graph
H.in_degree()
# InDegreeView({'A': 0, 'B': 1, 'C': 1, 'D': 1, 'E': 1, 'F': 1, 'G': 1, 'H': 1})

In [38]: for i in H.adjacency():
    ...:     print(i)
    ...:
# ('A', {'B': {}, 'C': {}})
# ('B', {'D': {}, 'E': {}, 'F': {}})
# ('C', {'G': {}})
# ('D', {})
# ('E', {})
# ('F', {'H': {}})
# ('G', {})
# ('H', {})
```